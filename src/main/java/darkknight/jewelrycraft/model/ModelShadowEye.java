// Date: 9/26/2014 1:50:53 PM
// Template version 1.1
// Java generated by Techne
// Keep in mind that you still need to fill in some blanks
// - ZeuX
package darkknight.jewelrycraft.model;

import org.lwjgl.opengl.GL11;

import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.entity.Entity;
import net.minecraft.util.Vec3;

public class ModelShadowEye extends ModelBase {
	// fields
	ModelRenderer Eye;
	ModelRenderer Platform1;
	ModelRenderer Platform2;
	ModelRenderer Atachement1;
	ModelRenderer Atachement2;
	ModelRenderer Cable1;
	ModelRenderer Cable2;
	ModelRenderer Cable3;
	ModelRenderer Cable4;
	float field_82221_e, field_82220_d;

	/**
     * 
     */
	public ModelShadowEye() {
		textureWidth = 64;
		textureHeight = 32;
		Eye = new ModelRenderer(this, 0, 0);
		Eye.addBox(-3.5F, -3.5F, -3.5F, 7, 7, 7);
		Eye.setRotationPoint(0F, 17.5F, 0F);
		Eye.setTextureSize(64, 32);
		Eye.mirror = true;
		setRotation(Eye, 0F, 0F, 0F);
		Platform1 = new ModelRenderer(this, 0, 14);
		Platform1.addBox(0F, 0F, 0F, 2, 2, 16);
		Platform1.setRotationPoint(-1F, 11F, -8F);
		Platform1.setTextureSize(64, 32);
		Platform1.mirror = true;
		setRotation(Platform1, 0F, 0F, 0F);
		Platform2 = new ModelRenderer(this, 0, 14);
		Platform2.addBox(0F, 0F, 0F, 2, 2, 16);
		Platform2.setRotationPoint(-1F, 22F, -8F);
		Platform2.setTextureSize(64, 32);
		Platform2.mirror = true;
		setRotation(Platform2, 0F, 0F, 0F);
		Atachement1 = new ModelRenderer(this, 38, 0);
		Atachement1.addBox(0F, 0F, 0F, 2, 2, 5);
		Atachement1.setRotationPoint(-1F, 17F, -12F);
		Atachement1.setTextureSize(64, 32);
		Atachement1.mirror = true;
		setRotation(Atachement1, 0F, 0F, 0F);
		Atachement2 = new ModelRenderer(this, 38, 0);
		Atachement2.addBox(0F, 0F, 0F, 2, 2, 5);
		Atachement2.setRotationPoint(-1F, 17F, 7F);
		Atachement2.setTextureSize(64, 32);
		Atachement2.mirror = true;
		setRotation(Atachement2, 0F, 0F, 0F);
		Cable1 = new ModelRenderer(this, 29, 0);
		Cable1.addBox(0F, 0F, 0F, 2, 6, 2);
		Cable1.setRotationPoint(-1F, 12F, 4.2F);
		Cable1.setTextureSize(64, 32);
		Cable1.mirror = true;
		setRotation(Cable1, 0.2617994F, 0F, 0F);
		Cable2 = new ModelRenderer(this, 29, 0);
		Cable2.addBox(0F, 0F, -1F, 2, 6, 2);
		Cable2.setRotationPoint(-1F, 12F, -5.2F);
		Cable2.setTextureSize(64, 32);
		Cable2.mirror = true;
		setRotation(Cable2, -0.2617994F, 0F, 0F);
		Cable3 = new ModelRenderer(this, 29, 0);
		Cable3.addBox(0F, 0F, 0F, 2, 6, 2);
		Cable3.setRotationPoint(-1F, 23F, -3.9F);
		Cable3.setTextureSize(64, 32);
		Cable3.mirror = true;
		setRotation(Cable3, -2.792527F, 0F, 0F);
		Cable4 = new ModelRenderer(this, 29, 0);
		Cable4.addBox(0F, 0F, -1F, 2, 6, 2);
		Cable4.setRotationPoint(-1F, 23F, 4.9F);
		Cable4.setTextureSize(64, 32);
		Cable4.mirror = true;
		setRotation(Cable4, 2.792527F, 0F, 0F);
	}

	/**
	 * @param entity
	 * @param f
	 * @param f1
	 * @param f2
	 * @param f3
	 * @param f4
	 * @param f5
	 */
	@Override
	public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
		Platform1.render(f5);
		Platform2.render(f5);
		Atachement1.render(f5);
		Atachement2.render(f5);
		Cable1.render(f5);
		Cable2.render(f5);
		Cable3.render(f5);
		Cable4.render(f5);
		if(f3 == 0) GL11.glRotatef(90F, 0F, -1F, 0F);
		else if(f3 == 1) GL11.glRotatef(180F, 0F, 1F, 0F);
		else if(f3 == 2) GL11.glRotatef(90F, 0F, 1F, 0F);
		Eye.render(f5);
		if (f4 == 4) 
		{
			Eye.rotateAngleX = f;
			Eye.rotateAngleY = f1;
			Eye.rotateAngleZ = f2;		
		}
		else
		{
			Eye.rotateAngleX = 0F;
			Eye.rotateAngleZ = 0F;
			if (f3 == 0) Eye.rotateAngleY = (float) (0.5F*Math.PI);
			else if (f3 == 1) Eye.rotateAngleY = (float) (Math.PI);
			else if (f3 == 2) Eye.rotateAngleY = (float) (1.5F*Math.PI);
			else if (f3 == 3) Eye.rotateAngleY = (float) (0F*Math.PI);
		}
	}

	public static float[] getRotation(double posX1, double posY1, double posZ1, double posX2, double posY2, double posZ2) 
	{
		float[] rotation = new float[2];
		double diffX = posX2 - posX1;
		double diffZ = posZ2 - posZ1;
		double diffY = posY2 - posY1;
		double dist = Math.sqrt(diffZ * diffZ + diffX * diffX);
		double pitch = -Math.toDegrees(Math.atan(diffY / dist));
		rotation[1] = (float) pitch;
		double yaw = 0;
		if (diffZ >= 0.0D && diffX >= 0.0D) {
			yaw = Math.toDegrees(-Math.atan(diffX / diffZ));
		} else if (diffZ >= 0.0D && diffX <= 0.0D) {
			yaw = Math.toDegrees(-Math.atan(diffX / diffZ));
		} else if (diffZ <= 0.0D && diffX >= 0.0D) {
			yaw = -90D + Math.toDegrees(Math.atan(diffZ / diffX));
		} else if (diffZ <= 0.0D && diffX <= 0.0D) {
			yaw = 90D + Math.toDegrees(Math.atan(diffZ / diffX));
		}
		rotation[0] = (float) yaw;
		return rotation;
	}

	/**
	 * @param model
	 * @param x
	 * @param y
	 * @param z
	 */
	private void setRotation(ModelRenderer model, float x, float y, float z) {
		model.rotateAngleX = x;
		model.rotateAngleY = y;
		model.rotateAngleZ = z;
	}
}
